<?php

/**
 * @file: Stackla Base module functions.
 */

/**
 * Implements hook_libraries_info().
 */
function stackla_libraries_info() {

  $libraries['stackla'] = array(
    'name' => 'Stackla',
    'vendor url' => 'http://stackla.com/',
    'download url' => 'http://stackla.com/api',
    'version' => 1,
    'files' => array(
      'php' => array('vendor/autoload.php'), //this can be a path to the file location like array('lib/simple.js')
    ),
  );

  return $libraries;
}

/**
 * Implements hook_menu().
 */
function stackla_menu() {
  $items = array();

  $items['admin/config/services/stackla'] = array(
    'title' => 'Stackla',
    'description' => 'Configure Stackla integration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('stackla_settings_form'),
    'access callback' => 'user_access',
    'access arguments' => array('administer stackla'),
    'file' => 'stackla.admin.inc',
    'weight' => 0,
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/services/stackla/test'] = array(
    'title' => 'Stackla: Test SDK integration',
    'description' => 'Test Stackla integration',
    'page callback' => 'stackla_test_api',
    'page arguments' => array('stackla_settings_form'),
    'access callback' => 'user_access',
    'access arguments' => array('administer stackla'),
    'weight' => 0,
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/services/stackla/accesscallback'] = array(
    'title' => 'Stackla: Access Callback',
    'description' => 'Callback for Stackal Oauth',
    'page callback' => 'stackla_outh_callback',
    'access callback' => 'user_access',
    'access arguments' => array('administer stackla'),
    'weight' => 0,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function stackla_permission() {
  return array(
    'administer stackla' => array(
      'title' => t('Administer stackla'),
      'description' => t('Configure stackla module'),
    ),
  );
}

/**
 * Callback for a page to test API connectivity.
 */
function stackla_test_api() {
  $output = array();

//@todo: write something meaningful here.
  return $ouput;
}

/**
 * Callback for Oauth authentication.
 */
function stackla_outh_callback() {
  libraries_load('stackla');
  $output = array();

  $access_code = $_GET['code'];
  $client_id = variable_get('stackla_client_id');
  $host = variable_get('stackla_stack_oauth_host');
  $stack = variable_get('stackla_stack_name');
  $client_secret = variable_get('stackla_client_secret');
  $callback = 'http://' . $_SERVER['HTTP_HOST'] . '/admin/config/services/stackla/accesscallback';

  $credentials = new Stackla\Core\Credentials($host, null, $stack);
  $response = $credentials->generateToken($client_id, $client_secret, $access_code, $callback);

  if ($response === false) {
    drupal_set_message(t('Failed creating access token.'), 'error');
  }
  else {
    stackla_set_access_token($credentials->token);
    drupal_set_message(t('Successfully created access token'), 'status');
  }
  drupal_goto('admin/config/services/stackla');
}

/**
 * Check Stacka authentication.
 *
 * @return bool
 *  TRUE if authenticated.
 */
function stackla_is_authenticated() {
  if (stackla_get_access_token()) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Retrieve Stackla access token.
 *
 *  @return string
 *    The access token string or FALSE if not present.
 */
function stackla_get_access_token() {
  $encrypted_token = variable_get('stackla_access_token');
  if ($encrypted_token) {
    return decrypt($encrypted_token);
  }
  else {
    return FALSE;
  }
}

/**
 * Set Stackla access token.
 *  @param string $token
 *    The token string to set.
 *  @return boolean
 *    TRUE if successful.
 */
function stackla_set_access_token($token) {
  $encrypted_token = encrypt($token);
  variable_set('stackla_access_token', $encrypted_token);
  return TRUE;
}

/**
 * Create a new Stackla Term
 *
 *  @param array $term
 *    Array of term data:
 *    'name' => The name of the term
 *    'network' => The machine name of the network eg 'twitter'.
 *    'type' => The query type machine name, eg 'hashtag'.
 *    'value' => They query value, eg 'bananas'.
 *  @return type
 *
 */
function stackla_create_term($term) {

  // Sim mode.
  if(variable_get('stackla_sim_mode') == 1) {
    watchdog('stackla', 'Simulating term creation. Values: <pre>@values</pre>', array(
      '@values' => print_r($term,TRUE),
    ), WATCHDOG_NOTICE);

    $new_term = new stdClass;
    $new_term->id = rand(1, 1000);

    return $new_term;
  }

  if(variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to create term. Values: <pre>@values</pre>', array(
      '@values' => print_r($term,TRUE),
    ), WATCHDOG_NOTICE);
  }

  $stack = stackla_create_stack();

  $new_term = $stack->instance('term');

  // populating term properties
  $new_term->name = $term['name'];
  $new_term->display_name = $term['name'];
  $new_term->active = 1;
  $new_term->num_of_backfill = 0;
  $new_term->term = $term['value'];
  $new_term->type = $term['type'];
  $new_term->filter = '';
  $new_term->network = $term['network'];

  // Create the term
  try{
    $new_term->create();
  } catch (Exception $ex) {
    dpm($new_term->getErrors(),'error');
  }


  return $new_term;
}

function stackla_update_term($term,$original_term) {
  // Sim mode.
  if(variable_get('stackla_sim_mode') == 1) {
    watchdog('stackla', 'Simulating term update. Values: <pre>@values</pre>', array(
      '@values' => print_r($term,TRUE),
    ), WATCHDOG_NOTICE);

    $updated_term = new stdClass;
    $updated_term->id = rand(1, 1000);

    return $updated_term;
  }

  if(variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to update term. Values: <pre>@values</pre>', array(
      '@values' => print_r($term,TRUE),
    ), WATCHDOG_NOTICE);
  }

  $stack = stackla_create_stack();

  $updated_term = $stack->instance('term',$term['stackla_id']);

  // populating term properties
  $updated_term->name = $term['name'];
  $updated_term->display_name = $term['name'];
  $updated_term->active = 1;
  $updated_term->num_of_backfill = 0;
  $updated_term->term = $term['value'];
  $updated_term->type = $term['type'];
  $updated_term->filter = '';
  $updated_term->network = $term['network'];

  // Create the term
  try{
    $updated_term->update();
  } catch (Exception $ex) {
    dpm($updated_term->getErrors(),'error');
  }


  return $updated_term;
}

function stackla_delete_term($term_id) {
  $stack = stackla_create_stack();

  $term = $stack->instance('term',$term_id);

  try{
    $term->delete();
  } catch (Exception $ex) {
    dpm($term->getErrors(),'error');
  }

  return $term;
}

/**
 * Create a Stackla Filter.
 * Refer to stackla API documentation for allowed values.
 *
 *  @param array $filter
 *    The filter data to create. Values:
 *      'name' (string) => The filter name.
 *      'networks' (array) => numerically keyed array of networks.
 *      'media' (array) => numerically keyed array of keys.
 *      'sort' (string) => sort type.
 *  @return obj
 *    The stacka filter object returned from the remote call.
 */
function stackla_create_filter($filter) {
  if(variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to create filter. Values: <pre>@values</pre>', array(
      '@values' => print_r($filter,TRUE),
    ), WATCHDOG_NOTICE);
  }

  $stack = stackla_create_stack();

  $new_filter = $stack->instance('filter');
  // Populate filter properties
  $new_filter->name = $filter['name'];
  $new_filter->networks = $filter['networks'];
  $new_filter->media = $filter['media'];
  $new_filter->sort = $filter['sort'];

  try{
    $new_filter->create();
  } catch (Exception $ex) {
    dpm($new_filter->getErrors(),'error');
  }

  return $new_filter;

}

function stackla_update_filter($filter,$original_filter) {

  $stack = stackla_create_stack();

  // Easiest way to update is create a new filter object locally,
  // populate with submitted data, then send.
  // In future we can get fancy here by only sending changed data etc.

  $updated_filter = $stack->instance('filter',$filter['stackla_id']);
  // Populate filter properties
  $updated_filter->name = $filter['name'];
  $updated_filter->networks = $filter['networks'];
  $updated_filter->media = $filter['media'];
  $updated_filter->sort = $filter['sort'];

  if(variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to update filter. New values: <pre>@new_values</pre>, original values: <pre>@orig_values</pre>, new filter object: <pre>@filter_obj</pre>', array(
      '@new_values' => print_r($filter,TRUE),
      '@orig_values' => print_r($original_filter,TRUE),
      '@filter_obj' => print_r($updated_filter,TRUE),
    ), WATCHDOG_NOTICE);
  }


  try{
    $updated_filter->update();
  } catch (Exception $ex) {
    dpm($updated_filter->getErrors(),'error');
  }

  return $updated_filter;
}

function stackla_create_stack() {

  // @todo: static cache.

  // Load the SDK.
  libraries_load('stackla');
  $stackla_variables = stackla_get_variables();

  if(variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to create stack. Values: <pre>@values</pre>', array(
      '@values' => print_r($stackla_variables,TRUE),
    ), WATCHDOG_NOTICE);
  }


  // Stackla stack name
  $stack_name = $stackla_variables['stack_name'];

  // Stackla Credentials details
  $accessHost = $stackla_variables['oauth_host'];
  $accessToken = $stackla_variables['access_token']; // OAuth2 access_token
  $credentials = new \Stackla\Core\Credentials($accessHost, $accessToken, $stack_name);

  // Stackla API configs
  $stackHost = $stackla_variables['host_name'];
  $stack = new \Stackla\Api\Stack($credentials, $stackHost, $stack_name);

  return $stack;
}

function stackla_get_variables() {
  $credentials = array(
    'stack_name' => variable_get('stackla_stack_name'),
    'oauth_host' => variable_get('stackla_oauth_host'),
    'host_name' => variable_get('stackla_host_name'),
    'stack_name' => variable_get('stackla_stack_name'),
    'access_token' => stackla_get_access_token(),
  );
  return $credentials;
}
