<?php

/**
 * @file: Stackla Base module functions.
 */

/**
 * Implements hook_libraries_info().
 */
function stackla_libraries_info() {

  $libraries['stackla'] = array(
    'name' => 'Stackla',
    'vendor url' => 'http://stackla.com/',
    'download url' => 'http://stackla.com/api',
    'version' => 1,
    'files' => array(
      'php' => array('vendor/autoload.php'), //this can be a path to the file location like array('lib/simple.js')
    ),
  );

  return $libraries;
}

/**
 * Implements hook_menu().
 */
function stackla_menu() {
  $items = array();

  $items['admin/config/services/stackla'] = array(
    'title' => 'Stackla',
    'description' => 'Configure Stackla integration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('stackla_settings_form'),
    'access callback' => 'user_access',
    'access arguments' => array('administer stackla'),
    'file' => 'stackla.admin.inc',
    'weight' => 0,
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/services/stackla/accesscallback'] = array(
    'title' => 'Stackla: Access Callback',
    'description' => 'Callback for Stackal Oauth',
    'page callback' => 'stackla_outh_callback',
    'access callback' => 'user_access',
    'access arguments' => array('administer stackla'),
    'weight' => 0,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function stackla_permission() {
  return array(
    'administer stackla' => array(
      'title' => t('Administer stackla'),
      'description' => t('Configure Stackla module'),
    ),
    'use stackla' => array(
      'title' => t('Use Stackla'),
      'description' => t('Create, edit and delete stackla widgets'),
    ),
  );
}

function stackla_check_requirements() {
  if (variable_get('stackla_stack_name') &&
      variable_get('stackla_stack_oauth_host') &&
      variable_get('stackla_stack_name') &&
      variable_get('stackla_client_id') &&
      variable_get('stackla_client_secret')
  ) {
    return TRUE;
  }
  return FALSE;
}

function stackla_authenticate() {
  global $base_url;
  libraries_load('stackla');
  if (!stackla_check_requirements()) {
    return FALSE;
  }
  $client_id = variable_get('stackla_client_id');
  $host = variable_get('stackla_stack_oauth_host');
  $stack = variable_get('stackla_stack_name');
  $client_secret = variable_get('stackla_client_secret');
  $callback = $base_url . '/admin/config/services/stackla/accesscallback';
  $credentials = new Stackla\Core\Credentials($host, null, $stack);
  $access_uri = $credentials->getAccessUri($client_id, $client_secret, $callback);

  drupal_goto($access_uri);
}

function stackla_user_authenticate($return_path = NULL) {
  if ($return_path) {
    // Store the return path in the user
    global $user;
    $user->data['stackla_return_path'] = $return_path;
    user_save($user);
  }
  stackla_authenticate();
}

/**
 * Callback for Oauth authentication.
 */
function stackla_outh_callback() {
  // Clear any other messages.
  drupal_get_messages();
  global $user;
  global $base_url;
  libraries_load('stackla');
  $output = array();

  $access_code = $_GET['code'];
  $client_id = variable_get('stackla_client_id');
  $host = variable_get('stackla_stack_oauth_host');
  $stack = variable_get('stackla_stack_name');
  $client_secret = variable_get('stackla_client_secret');
  $callback = $base_url . '/admin/config/services/stackla/accesscallback';

  if (variable_get('stackla_debug_mode') == 1) {
    watchdog('stackla', 'Sending token request: host: @host, stack: @stack client id: @client_id, client secret: @client_secret, access code: @access_code, callback: @callback', array(
      '@stack' => $stack,
      '@host' => $host,
      '@client_id' => $client_id,
      '@client_secret' => $client_secret,
      '@access_code' => $access_code,
      '@callback' => $callback,
    ));
  }

  $credentials = new Stackla\Core\Credentials($host, null, $stack);
  $response = $credentials->generateToken($client_id, $client_secret, $access_code, $callback);

  if ($response === false) {
    drupal_set_message(t('Failed creating access token.'), 'error');
  }
  else {
    stackla_set_access_token($credentials->token);
    drupal_set_message(t('Successfully created access token'), 'status');
  }
  if (!empty($user->data['stackla_return_path'])) {
    $goto = $user->data['stackla_return_path'];
    unset($user->data['stackla_return_path']);
    user_save($user);
  }
  else {
    $goto = 'admin/config/services/stackla';
  }
  drupal_goto($goto);
}

/**
 * Check Stacka authentication.
 *
 * @return bool
 *  TRUE if authenticated.
 */
function stackla_is_authenticated() {
  if (stackla_get_access_token()) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Retrieve Stackla access token.
 *
 *  @return string
 *    The access token string or FALSE if not present.
 */
function stackla_get_access_token() {
  global $user;
  if (!empty($user->data['stackla_access_token'])) {
    return decrypt($user->data['stackla_access_token']);
  }
  else {
    return FALSE;
  }
}

/**
 * Set Stackla access token.
 *  @param string $token
 *    The token string to set.
 *  @return boolean
 *    TRUE if successful.
 */
function stackla_set_access_token($token) {
  $encrypted_token = encrypt($token);
  global $user;
  $user->data['stackla_access_token'] = $encrypted_token;
  user_save($user);
  return TRUE;
}

/**
 * Create a new Stackla Term
 *
 *  @param array $term
 *    Array of term data:
 *    'name' => The name of the term
 *    'network' => The machine name of the network eg 'twitter'.
 *    'type' => The query type machine name, eg 'hashtag'.
 *    'value' => They query value, eg 'bananas'.
 *  @return type
 *
 */
function stackla_create_term($term) {

  // Sim mode.
  if (variable_get('stackla_sim_mode') == 1) {
    watchdog('stackla', 'Simulating term creation. Values: <pre>@values</pre>', array(
      '@values' => print_r($term, TRUE),
        ), WATCHDOG_NOTICE);

    $new_term = new stdClass;
    $new_term->id = rand(1, 1000);

    return $new_term;
  }

  if (variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to create term. Values: <pre>@values</pre>', array(
      '@values' => print_r($term, TRUE),
        ), WATCHDOG_NOTICE);
  }

  $stack = stackla_create_stack();

  $new_term = $stack->instance('term');

  // populating term properties
  $new_term->name = $term['name'];
  $new_term->display_name = $term['name'];
  $new_term->active = 1;
  $new_term->num_of_backfill = 0;
  $new_term->term = $term['value'];
  $new_term->type = $term['type'];
  $new_term->filter = '';
  $new_term->network = $term['network'];

  // Create the term
  try {
    $new_term->create();
  } catch (Exception $ex) {
    dpm($new_term->getErrors(), 'error creating tag');
  }

  if (!empty($term['tag_id'])) {
    $tag = stackla_load_tag($term['tag_id']);
    try {
      $new_term->addTag($tag);
    } catch (Exception $ex) {
      dpm($new_term->getErrors(), 'error adding tag to term');
    }
  }
  return $new_term;
}

function stackla_update_term($term, $original_term) {
  // Sim mode.
  if (variable_get('stackla_sim_mode') == 1) {
    watchdog('stackla', 'Simulating term update. Values: <pre>@values</pre>', array(
      '@values' => print_r($term, TRUE),
        ), WATCHDOG_NOTICE);

    $updated_term = new stdClass;
    $updated_term->id = rand(1, 1000);

    return $updated_term;
  }

  if (variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to update term. Values: <pre>@values</pre>', array(
      '@values' => print_r($term, TRUE),
        ), WATCHDOG_NOTICE);
  }

  $stack = stackla_create_stack();

  $updated_term = $stack->instance('term', $term['stackla_id']);

  // populating term properties
  $updated_term->name = $term['name'];
  $updated_term->display_name = $term['name'];
  $updated_term->active = 1;
  $updated_term->num_of_backfill = 0;
  $updated_term->term = $term['value'];
  $updated_term->type = $term['type'];
  $updated_term->filter = '';
  $updated_term->network = $term['network'];

  // Create the term
  try {
    $updated_term->update();
  } catch (Exception $ex) {
    dpm($updated_term->getErrors(), 'error');
  }


  return $updated_term;
}

function stackla_delete_term($term_id) {
  $stack = stackla_create_stack();

  $term = $stack->instance('term', $term_id, FALSE);

  try {
    $term->delete();
  } catch (Exception $ex) {
    dpm($term->getErrors(), 'error');
  }

  return $term;
}

/**
 * Create a Stackla Filter.
 * Refer to stackla API documentation for allowed values.
 *
 *  @param array $filter
 *    The filter data to create. Values:
 *      'name' (string) => The filter name.
 *      'networks' (array) => numerically keyed array of networks.
 *      'media' (array) => numerically keyed array of keys.
 *      'sort' (string) => sort type.
 *  @return obj
 *    The stacka filter object returned from the remote call.
 */
function stackla_create_filter($filter) {
  if (variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to create filter. Values: <pre>@values</pre>', array(
      '@values' => print_r($filter, TRUE),
        ), WATCHDOG_NOTICE);
  }

  $stack = stackla_create_stack();

  $new_filter = $stack->instance('filter');
  // Populate filter properties
  $new_filter->name = $filter['name'];
  $new_filter->networks = $filter['networks'];
  $new_filter->media = $filter['media'];
  $new_filter->sort = $filter['sort'];

  if (!empty($filter['tag_id'])) {
    $tag = stackla_load_tag($filter['tag_id']);
    try {
      $new_filter->addTag($tag);
    } catch (Exception $ex) {
      dpm($new_filter->getErrors(), 'error adding tag to filter');
    }
  }

  try {
    $new_filter->create();
  } catch (Exception $ex) {
    dpm($new_filter->getErrors(), 'error');
  }

  return $new_filter;
}

function stackla_update_filter($filter, $original_filter) {

  $stack = stackla_create_stack();

  // Easiest way to update is create a new filter object locally,
  // populate with submitted data, then send.
  // In future we can get fancy here by only sending changed data etc.

  $updated_filter = $stack->instance('filter', $filter['stackla_id']);
  // Populate filter properties
  $updated_filter->name = $filter['name'];
  $updated_filter->networks = $filter['networks'];
  $updated_filter->media = $filter['media'];
  $updated_filter->sort = $filter['sort'];

  if (variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to update filter. New values: <pre>@new_values</pre>, original values: <pre>@orig_values</pre>, new filter object: <pre>@filter_obj</pre>', array(
      '@new_values' => print_r($filter, TRUE),
      '@orig_values' => print_r($original_filter, TRUE),
      '@filter_obj' => print_r($updated_filter, TRUE),
        ), WATCHDOG_NOTICE);
  }


  try {
    $updated_filter->update();
  } catch (Exception $ex) {
    dpm($updated_filter->getErrors(), 'error');
  }

  return $updated_filter;
}

function stackla_delete_filter($filter_id) {
  $stack = stackla_create_stack();

  $filter = $stack->instance('filter', $filter_id, FALSE);

  try {
    $filter->delete();
  } catch (Exception $ex) {
    dpm($filter->getErrors(), 'error');
  }

  return $filter;
}

function stackla_create_tag($tag) {
  $stack = stackla_create_stack();

  $new_tag = $stack->instance('tag');

  // Populate filter properties
  $new_tag->tag = $tag['tag'];
  $new_tag->type = $tag['type'];
  $new_tag->publicly_visible = $tag['publicly_visible'];

  try {
    $new_tag->create();
  } catch (Exception $ex) {
    dpm($new_tag->getErrors(), 'error');
  }

  return $new_tag;
}

function stackla_load_tag($tag_id, $fetch = true) {
  $stack = stackla_create_stack();

  $tag = $stack->instance('tag', $tag_id, $fetch);

  return $tag;
}

/**
 * Create widget
 *  @param array $widget
 *    Widget parameters
 * @return object
 *  Created object or object with errors as per the SDK.
 */
function stackla_create_widget($widget) {
  $stack = stackla_create_stack();

  $new_widget = $stack->instance('widget');

  // Populate filter properties
  $new_widget->name = $widget['name'];
  $new_widget->type = $widget['type'];
  $new_widget->type_style = $widget['type_style'];
  $new_widget->filter_id = $widget['filter_id'];

  if (variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to create widget. New values: <pre>@new_values</pre>', array(
      '@new_values' => print_r($widget, TRUE),
        ), WATCHDOG_NOTICE);
  }

  try {
    $new_widget->create();
  } catch (Exception $ex) {
    dpm($new_widget->getErrors(), 'exception in create widget:');
  }

  return $new_widget;
}

/**
 * Update a widget
 *  @param array $widget
 *    Widget parameters.
 */
function stackla_update_widget($widget) {
  $stack = stackla_create_stack();

  // Easiest way to update is create a new filter object locally,
  // populate with submitted data, then send.
  // In future we can get fancy here by only sending changed data etc.

  $updated_widget = $stack->instance('widget', $widget['stackla_id']);
  // Populate filter properties
  $updated_widget->name = $widget['name'];
  $updated_widget->type = $widget['type'];
  $updated_widget->type_style = $widget['type_style'];
  $updated_widget->filter_id = $widget['filter_id'];

  if (variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to update widget. New values: <pre>@new_values</pre>, new widget object: <pre>@filter_obj</pre>', array(
      '@new_values' => print_r($widget, TRUE),
      '@filter_obj' => print_r($updated_widget, TRUE),
        ), WATCHDOG_NOTICE);
  }

  try {
    $updated_widget->update();
  } catch (Exception $ex) {
    dpm($updated_widget->getErrors(), 'error');
  }

  return $updated_widget;
}

function stackla_get_widgets($limit = 25, $page = 1, $options = array()) {
  $stack = stackla_create_stack();
  $widgets = $stack->instance('widget');

  $widgets->get($limit, $page, $options);

  return $widgets;
}

function stackla_load_widget($widget_id) {
  $stack = stackla_create_stack();
  $widget = $stack->instance('widget', $widget_id);

  return $widget;
}

function stackla_clone_widget($widget) {
  dpm($widget, 'clone called');
  $stackla = stackla_create_stack();
  $clone_parent_id = $widget['clone_parent'];

  $clone_parent = stackla_load_widget($clone_parent_id);

  $new_widget = $clone_parent->duplicate();

  // update the new widget with the selected type_style.

  $new_widget->type_style = $widget['type_style'];

  $new_widget->filter_id = $widget['filter_id'];

  $new_widget->update();

  return $new_widget;
}

function stackla_derive_widget($widget) {
  $stackla = stackla_create_stack();

  $derive_parent_id = $widget['derive_parent'];

  $derive_parent = stackla_load_widget($derive_parent_id);

  $new_widget = $derive_parent->derive($widget['filter_id'], $widget['name']);

  return $new_widget;
}

function stackla_delete_widget($widget_id) {
  $stackla = stackla_create_stack();

  $widget = $stack->instance('widget', $widget_id, FALSE);

  try {
    $widget->delete();
  } catch (Exception $ex) {
    dpm($widget->getErrors(), 'error');
  }

  return $widget;
}

/**
 * Create stack via the Stackla SDK.
 * @return \Stackla\Api\Stack
 */
function stackla_create_stack() {

  // @todo: static cache.
  // Load the SDK.
  libraries_load('stackla');
  $stackla_variables = stackla_get_variables();

  if (variable_get('stackla_debug_mode') == 1) {

    watchdog('stackla', 'Attempting to create stack. Values: <pre>@values</pre>', array(
      '@values' => print_r($stackla_variables, TRUE),
        ), WATCHDOG_NOTICE);
  }


  // Stackla stack name
  $stack_name = $stackla_variables['stack_name'];

  // Stackla Credentials details
  $accessHost = $stackla_variables['oauth_host'];
  $accessToken = $stackla_variables['access_token']; // OAuth2 access_token
  $credentials = new \Stackla\Core\Credentials($accessHost, $accessToken, $stack_name);

  // Stackla API configs
  $stackHost = $stackla_variables['host_name'];
  $stack = new \Stackla\Api\Stack($credentials, $stackHost, $stack_name);

  return $stack;
}

function stackla_get_variables() {
  $credentials = array(
    'stack_name' => variable_get('stackla_stack_name'),
    'oauth_host' => variable_get('stackla_oauth_host'),
    'host_name' => variable_get('stackla_host_name'),
    'stack_name' => variable_get('stackla_stack_name'),
    'access_token' => stackla_get_access_token(),
  );
  return $credentials;
}
